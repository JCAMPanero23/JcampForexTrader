using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Threading;
using ScottPlot;
using ScottPlot.Plottables;
using JcampForexTrader.Backtest;
using JcampForexTrader.Services;

namespace JcampForexTrader
{
    public partial class ChartViewerWindow : Window
    {
        // DEBUG FLAG: Set to false to suppress verbose debug output
        private const bool ENABLE_VERBOSE_DEBUG = false;

        private OhlcData _ohlcData;
        private int _currentBarIndex = 0;
        private bool _isPlaying = false;
        private DispatcherTimer _playbackTimer;
        private List<TradeWithLevels> _activeTrades = new List<TradeWithLevels>();
        private double _cumulativeR = 0.0;
        private int _winsCount = 0;
        private int _lossesCount = 0;

        // Chart elements for dynamic updates
        private List<IPlottable> _candlePlottables = new List<IPlottable>();
        private List<IPlottable> _tradePlottables = new List<IPlottable>();

        // Viewport state for persistence
        private AxisLimits? _savedAxisLimits = null;

        // M1 playback mode support
        private PlaybackMode _playbackMode = PlaybackMode.Standard;
        private int _m1BarIndex = 0;
        private bool _m1DataLoaded = false;
        private string _taskId = null;

        // Flag to prevent slider ValueChanged event from triggering during programmatic updates
        private bool _isUpdatingSliderProgrammatically = false;

        // EMA visibility flags for multi-timeframe overlay
        private bool _showM15Emas = true;
        private bool _showH1Emas = true;

        // Sequential index mapping to remove weekend gaps
        // Maps bar index (0, 1, 2...) to actual DateTime for display
        private List<DateTime> _indexToDateTime = new List<DateTime>();

        // Phase 8.2.2: Multi-pair support
        private bool _isMultiPair = false;
        private Dictionary<string, OhlcData> _pairData = new Dictionary<string, OhlcData>();
        private List<Backtest.TradeRecord> _allTradesChronological = new List<Backtest.TradeRecord>();
        private string _currentPair = "";
        private MultiPairBacktestResults _multiPairResults = null;

        // Phase 8.2.5: Global timeline for multi-pair synchronization
        private List<DateTime> _globalTimeline = new List<DateTime>();
        private Dictionary<string, Dictionary<DateTime, int>> _pairTimelineMapping = new Dictionary<string, Dictionary<DateTime, int>>();
        private int _globalTimelineIndex = 0;

        // Phase 8.3: Visual trade timeline
        private List<TradeTimelineEvent> _tradeTimelineEvents = new List<TradeTimelineEvent>();
        private Dictionary<string, System.Windows.Media.Color> _pairColors = new Dictionary<string, System.Windows.Media.Color>();

        public ChartViewerWindow(OhlcData ohlcData, string taskId = null)
        {
            InitializeComponent();
            _ohlcData = ohlcData;
            _taskId = taskId;

            // Pre-calculate EMAs for all timeframes (M15, H1, H4)
            PreCalculateMultiTimeframeEMAs();

            // Run diagnostic to identify EMA issues (OPTIONAL - comment out after debugging)
            // DiagnoseEmaIssues();

            InitializeChart();
            InitializePlayback();
            UpdateSymbolInfo();
            InitializeRightPanel();

            // Initialize viewport with default settings (100 pips Y-axis, 1 day X-axis)
            AdvanceToBar(0);

            // Populate Recent Trades list (Enhancement #1)
            PopulateRecentTradesList();

            // Load M1 data if taskId is provided
            if (!string.IsNullOrEmpty(taskId))
            {
                LoadM1DataAsync(taskId);
            }
        }

        // Phase 8.2.2: Multi-pair constructor
        public ChartViewerWindow(MultiPairBacktestResults results)
        {
            InitializeComponent();
            _isMultiPair = true;
            _multiPairResults = results;

            // Validate results
            if (results == null)
            {
                throw new ArgumentNullException(nameof(results), "MultiPairBacktestResults cannot be null");
            }

            if (results.PairChartData == null || results.PairChartData.Count == 0)
            {
                var pairList = results.PairBreakdown != null
                    ? string.Join(", ", results.PairBreakdown.Keys)
                    : "unknown";
                throw new InvalidOperationException(
                    $"PairChartData is empty. Pairs in breakdown: {pairList}. " +
                    $"Total trades: {results.Trades?.Count ?? 0}. " +
                    "This usually means chart data wasn't generated by the Python API.");
            }

            // Convert ChartData to OhlcData for each pair
            foreach (var kvp in results.PairChartData)
            {
                var symbol = kvp.Key;
                var chartData = kvp.Value;

                // Validate chart data
                if (chartData == null || chartData.M15Candles == null || chartData.M15Candles.Count == 0)
                {
                    System.Diagnostics.Debug.WriteLine($"[WARN] Skipping {symbol}: No M15 candles");
                    continue;
                }

                // Convert to OhlcData format
                var ohlcData = new OhlcData
                {
                    Symbol = symbol,
                    Candles = chartData.M15Candles,
                    M1Candles = chartData.M1Candles ?? new List<CandleData>(),
                    Trades = ConvertToTradeWithLevels(results.Trades.Where(t => t.Symbol == symbol).ToList()),
                    PipSize = GetPipSize(symbol),
                    DecimalPlaces = GetDecimalPlaces(symbol)
                };

                _pairData[symbol] = ohlcData;
            }

            // Final check after populating
            if (_pairData.Count == 0)
            {
                throw new InvalidOperationException(
                    "No valid pair data loaded. All pairs may have missing M15 candles.");
            }

            // Set first pair as current
            _currentPair = _pairData.Keys.First();
            _ohlcData = _pairData[_currentPair];

            // Store all trades chronologically
            _allTradesChronological = results.Trades.OrderBy(t => t.EntryTime).ToList();

            // Generate pair tabs dynamically
            GeneratePairTabs(_pairData.Keys.ToList());

            // Phase 8.2.5: Build global timeline for synchronized playback
            BuildGlobalTimeline();

            // Pre-calculate EMAs for all timeframes (M15, H1, H4)
            PreCalculateMultiTimeframeEMAs();

            InitializeChart();
            InitializePlayback();
            UpdateSymbolInfo();
            InitializeRightPanel();

            // Initialize viewport with default settings
            AdvanceToBar(0);

            // Populate Recent Trades list (Enhancement #1)
            PopulateRecentTradesList();
        }

        // Phase 8.2.2: Helper methods for multi-pair support
        private double GetPipSize(string symbol)
        {
            // JPY pairs have pip size of 0.01, others 0.0001
            return symbol.Contains("JPY") ? 0.01 : 0.0001;
        }

        private int GetDecimalPlaces(string symbol)
        {
            // JPY pairs have 3 decimal places, others 5
            return symbol.Contains("JPY") ? 3 : 5;
        }

        private List<TradeWithLevels> ConvertToTradeWithLevels(List<Backtest.TradeRecord> trades)
        {
            return trades.Select(t => new TradeWithLevels
            {
                TicketNumber = t.PositionId,
                Symbol = t.Symbol,
                Side = t.Side.ToUpper(), // Convert "BUY"/"SELL" to uppercase
                Strategy = t.Strategy,
                EntryTime = t.EntryTime,
                ExitTime = t.ExitTime,
                EntryPrice = t.EntryPrice,
                ExitPrice = t.ExitPrice,
                StopLoss = t.StopLoss,
                TakeProfit = t.TakeProfit,
                RMultiple = t.RMultiple,
                ProfitLoss = t.ProfitLoss,
                ExitReason = t.ExitReason,
                IsWin = (t.RMultiple ?? 0) > 0
            }).ToList();
        }

        private void GeneratePairTabs(List<string> pairs)
        {
            System.Diagnostics.Debug.WriteLine($"[PAIR TABS] Generating tabs for {pairs.Count} pairs: {string.Join(", ", pairs)}");

            // Clear any existing tabs
            PairTabControl.Items.Clear();

            bool isFirstTab = true;

            foreach (string pair in pairs)
            {
                // Create new TabItem
                var tabItem = new System.Windows.Controls.TabItem
                {
                    Header = GetPairDisplayName(pair),  // Display with broker suffix (EURUSD_sml)
                    Background = new System.Windows.Media.SolidColorBrush(
                        (System.Windows.Media.Color)System.Windows.Media.ColorConverter.ConvertFromString("#2D2D30")),
                    Foreground = new System.Windows.Media.SolidColorBrush(
                        isFirstTab
                            ? System.Windows.Media.Colors.White
                            : (System.Windows.Media.Color)System.Windows.Media.ColorConverter.ConvertFromString("#888888")),
                    FontSize = 12,
                    IsSelected = isFirstTab,  // First tab selected by default
                    Tag = pair  // Store clean pair name for internal use (EURUSD)
                };

                // Add empty content to match XAML structure
                tabItem.Content = new System.Windows.Controls.Grid { Height = 0 };

                // Add tab to control
                PairTabControl.Items.Add(tabItem);

                System.Diagnostics.Debug.WriteLine($"[PAIR TABS] Created tab for {pair} (Selected: {isFirstTab})");

                isFirstTab = false;
            }

            System.Diagnostics.Debug.WriteLine($"[PAIR TABS] Total tabs created: {PairTabControl.Items.Count}");
        }

        /// <summary>
        /// Get display name for pair (adds broker suffix for UI display)
        /// Internal logic uses clean pair names (EURUSD), UI shows with suffix (EURUSD_sml)
        /// </summary>
        private string GetPairDisplayName(string pair)
        {
            // Configuration: Broker suffix
            const string BROKER_SUFFIX = "_sml";

            // Add suffix for display only
            return pair + BROKER_SUFFIX;
        }

        // Phase 8.2.5: Build global timeline from all pairs
        private void BuildGlobalTimeline()
        {
            if (!_isMultiPair)
                return;

            // Collect all unique timestamps from all pairs
            var allTimestamps = new HashSet<DateTime>();

            foreach (var kvp in _pairData)
            {
                var symbol = kvp.Key;
                var ohlcData = kvp.Value;

                // Create mapping for this pair: timestamp â†’ bar index
                var pairMapping = new Dictionary<DateTime, int>();

                for (int i = 0; i < ohlcData.Candles.Count; i++)
                {
                    var timestamp = ohlcData.Candles[i].GetDateTime();
                    allTimestamps.Add(timestamp);
                    pairMapping[timestamp] = i;
                }

                _pairTimelineMapping[symbol] = pairMapping;
            }

            // Create sorted global timeline
            _globalTimeline = allTimestamps.OrderBy(t => t).ToList();

            System.Diagnostics.Debug.WriteLine($"[GLOBAL TIMELINE] Built timeline with {_globalTimeline.Count} unique timestamps across {_pairData.Count} pairs");
            System.Diagnostics.Debug.WriteLine($"[GLOBAL TIMELINE] Start: {_globalTimeline.First():yyyy-MM-dd HH:mm}, End: {_globalTimeline.Last():yyyy-MM-dd HH:mm}");

            // Build trade timeline after global timeline
            BuildTradeTimeline();
        }

        // Phase 8.3: Build trade timeline events from multi-pair results
        private void BuildTradeTimeline()
        {
            if (!_isMultiPair || _multiPairResults == null || _multiPairResults.Trades == null)
                return;

            _tradeTimelineEvents.Clear();

            // Assign colors to pairs
            var pairList = _pairData.Keys.ToList();
            var colors = new[] {
                System.Windows.Media.Color.FromRgb(0, 170, 255),   // Blue - EURUSD
                System.Windows.Media.Color.FromRgb(255, 170, 0),   // Orange - GBPUSD
                System.Windows.Media.Color.FromRgb(170, 0, 255),   // Purple - USDJPY
                System.Windows.Media.Color.FromRgb(0, 255, 170),   // Cyan
                System.Windows.Media.Color.FromRgb(255, 0, 170),   // Pink
                System.Windows.Media.Color.FromRgb(170, 255, 0),   // Lime
            };

            for (int i = 0; i < pairList.Count; i++)
            {
                _pairColors[pairList[i]] = colors[i % colors.Length];
            }

            // Create timeline events for each trade
            foreach (var trade in _multiPairResults.Trades)
            {
                var entryTime = DateTime.Parse(trade.EntryTime);
                DateTime? exitTime = string.IsNullOrEmpty(trade.ExitTime) ? (DateTime?)null : DateTime.Parse(trade.ExitTime);

                // Entry event
                int entryGlobalIndex = _globalTimeline.IndexOf(entryTime);
                if (entryGlobalIndex >= 0)
                {
                    _tradeTimelineEvents.Add(new TradeTimelineEvent
                    {
                        Timestamp = entryTime,
                        Pair = trade.Symbol,
                        EventType = "ENTRY",
                        TradeId = trade.PositionId,
                        Side = trade.Side,
                        Strategy = trade.Strategy,
                        GlobalTimelineIndex = entryGlobalIndex
                    });
                }

                // Exit event
                if (exitTime.HasValue)
                {
                    int exitGlobalIndex = _globalTimeline.IndexOf(exitTime.Value);
                    if (exitGlobalIndex >= 0)
                    {
                        _tradeTimelineEvents.Add(new TradeTimelineEvent
                        {
                            Timestamp = exitTime.Value,
                            Pair = trade.Symbol,
                            EventType = "EXIT",
                            TradeId = trade.PositionId,
                            Side = trade.Side,
                            RMultiple = trade.RMultiple,
                            Strategy = trade.Strategy,
                            GlobalTimelineIndex = exitGlobalIndex
                        });
                    }
                }
            }

            // Sort by timestamp
            _tradeTimelineEvents = _tradeTimelineEvents.OrderBy(e => e.Timestamp).ToList();

            System.Diagnostics.Debug.WriteLine($"[TRADE TIMELINE] Built {_tradeTimelineEvents.Count} trade events across {_pairColors.Count} pairs");

            // Render the timeline
            RenderTradeTimeline();
        }

        // Phase 8.3: Render trade timeline on canvas
        private void RenderTradeTimeline()
        {
            if (TradeTimelineCanvas == null || _tradeTimelineEvents.Count == 0 || _globalTimeline.Count == 0)
                return;

            TradeTimelineCanvas.Children.Clear();

            double canvasWidth = TradeTimelineCanvas.ActualWidth;
            double canvasHeight = TradeTimelineCanvas.ActualHeight;

            // Use actual width if available, otherwise estimate
            if (canvasWidth <= 0)
                canvasWidth = 1200; // Estimated width

            if (canvasHeight <= 0)
                canvasHeight = 60;

            foreach (var evt in _tradeTimelineEvents)
            {
                // Calculate X position based on global timeline
                double xPos = (evt.GlobalTimelineIndex / (double)_globalTimeline.Count) * canvasWidth;

                // Color by pair
                var color = _pairColors.ContainsKey(evt.Pair) ? _pairColors[evt.Pair] : System.Windows.Media.Colors.Gray;

                // Create rectangle marker
                var rect = new System.Windows.Shapes.Rectangle
                {
                    Width = 3,
                    Height = evt.EventType == "ENTRY" ? canvasHeight * 0.6 : canvasHeight * 0.4,
                    Fill = new System.Windows.Media.SolidColorBrush(color),
                    Stroke = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Colors.White),
                    StrokeThickness = 0.5,
                    Tag = evt
                };

                // Position on canvas
                System.Windows.Controls.Canvas.SetLeft(rect, xPos);
                System.Windows.Controls.Canvas.SetTop(rect, evt.EventType == "ENTRY" ? 0 : canvasHeight * 0.6);

                // Add tooltip
                rect.ToolTip = $"{evt.Pair} - {evt.EventType}\n" +
                              $"Trade #{evt.TradeId}\n" +
                              $"{evt.Side} ({evt.Strategy})\n" +
                              $"{evt.Timestamp:yyyy-MM-dd HH:mm}" +
                              (evt.RMultiple.HasValue ? $"\nR: {evt.RMultiple:+0.0;-0.0}" : "");

                TradeTimelineCanvas.Children.Add(rect);
            }

            // Add current position indicator
            RenderTimelinePositionIndicator();
        }

        private void RenderTimelinePositionIndicator()
        {
            if (TradeTimelineCanvas == null || _globalTimeline.Count == 0)
                return;

            // Remove existing position indicator
            var existingIndicator = TradeTimelineCanvas.Children.OfType<System.Windows.Shapes.Line>()
                .FirstOrDefault(l => l.Tag as string == "POSITION_INDICATOR");
            if (existingIndicator != null)
                TradeTimelineCanvas.Children.Remove(existingIndicator);

            double canvasWidth = TradeTimelineCanvas.ActualWidth > 0 ? TradeTimelineCanvas.ActualWidth : 1200;
            double canvasHeight = TradeTimelineCanvas.ActualHeight > 0 ? TradeTimelineCanvas.ActualHeight : 60;

            // Calculate X position
            double xPos = (_globalTimelineIndex / (double)_globalTimeline.Count) * canvasWidth;

            // Create vertical line indicator
            var line = new System.Windows.Shapes.Line
            {
                X1 = xPos,
                Y1 = 0,
                X2 = xPos,
                Y2 = canvasHeight,
                Stroke = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Colors.Yellow),
                StrokeThickness = 2,
                Tag = "POSITION_INDICATOR"
            };

            TradeTimelineCanvas.Children.Add(line);
        }

        // Phase 8.3: Handle timeline canvas click
        private void TradeTimelineCanvas_Click(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            if (_globalTimeline.Count == 0)
                return;

            // Get click position
            var pos = e.GetPosition(TradeTimelineCanvas);
            double canvasWidth = TradeTimelineCanvas.ActualWidth;

            // Calculate global timeline index from click position
            int targetIndex = (int)((pos.X / canvasWidth) * _globalTimeline.Count);
            targetIndex = Math.Max(0, Math.Min(targetIndex, _globalTimeline.Count - 1));

            System.Diagnostics.Debug.WriteLine($"[TIMELINE CLICK] Jumping to index {targetIndex} (click at x={pos.X})");

            // Jump to this position
            StopPlayback();

            _globalTimelineIndex = targetIndex;
            _cumulativeR = 0.0;
            _winsCount = 0;
            _lossesCount = 0;
            _activeTrades.Clear();
            _savedAxisLimits = null;

            // Replay trades
            ReplayTradesUpToGlobalTime(targetIndex);

            // Advance timeline
            AdvanceGlobalTimeline(targetIndex);

            // Update position indicator
            RenderTimelinePositionIndicator();
        }

        // Phase 8.3: Handle canvas resize - re-render timeline
        private void TradeTimelineCanvas_SizeChanged(object sender, System.Windows.SizeChangedEventArgs e)
        {
            if (_tradeTimelineEvents.Count > 0)
            {
                RenderTradeTimeline();
            }
        }

        // Phase 8.5: Handle pair tab selection (BUG1 fix)
        private void PairTabControl_SelectionChanged(object sender, System.Windows.Controls.SelectionChangedEventArgs e)
        {
            if (!_isMultiPair || e.AddedItems.Count == 0)
                return;

            var selectedTab = e.AddedItems[0] as System.Windows.Controls.TabItem;
            if (selectedTab != null)
            {
                // Get pair name from Tab's Tag (more reliable) or fallback to Header
                string pairName = selectedTab.Tag?.ToString() ?? selectedTab.Header.ToString();

                System.Diagnostics.Debug.WriteLine($"[PAIR TAB] User selected tab: {pairName}");

                // Verify pair exists in loaded data
                if (!_pairData.ContainsKey(pairName))
                {
                    System.Diagnostics.Debug.WriteLine($"[PAIR TAB ERROR] Pair '{pairName}' not found in loaded data!");
                    return;
                }

                SwitchToPairTab(pairName);
            }
        }

        private void SwitchToPairTab(string pair)
        {
            if (!_pairData.ContainsKey(pair))
                return;

            _currentPair = pair;
            _ohlcData = _pairData[pair];

            // Redraw chart for selected pair
            if (_isMultiPair && _globalTimeline.Count > 0 && _globalTimelineIndex >= 0 && _globalTimelineIndex < _globalTimeline.Count)
            {
                // In global timeline mode: map current global time to bar index for this pair
                var currentGlobalTime = _globalTimeline[_globalTimelineIndex];

                if (_pairTimelineMapping.ContainsKey(pair) && _pairTimelineMapping[pair].ContainsKey(currentGlobalTime))
                {
                    int barIndex = _pairTimelineMapping[pair][currentGlobalTime];
                    _currentBarIndex = barIndex;
                    AdvanceToBar(barIndex);
                }
                else
                {
                    // Fallback if timestamp doesn't exist for this pair
                    AdvanceToBar(0);
                }
            }
            else
            {
                // Single-pair mode or no global timeline: maintain current bar index
                AdvanceToBar(_currentBarIndex);
            }

            System.Diagnostics.Debug.WriteLine($"[PAIR SWITCH] Switched to {pair} at global timeline index {_globalTimelineIndex}");
        }

        private void InitializeChart()
        {
            var plot = ChartPlot.Plot;

            // Set dark theme
            plot.FigureBackground.Color = ScottPlot.Color.FromHex("#000000");
            plot.DataBackground.Color = ScottPlot.Color.FromHex("#000000");

            // Configure axes
            plot.Axes.Color(ScottPlot.Color.FromHex("#CCCCCC"));
            plot.Grid.MajorLineColor = ScottPlot.Color.FromHex("#111112");
            plot.Grid.MinorLineColor = ScottPlot.Color.FromHex("#111112");

            // Set axis labels
            plot.XLabel("Time");
            plot.YLabel("Price");
            plot.Title($"{_ohlcData.Symbol} - Backtest Playback");

            // CUSTOM TWO-LINE DATETIME LABELS WITH SQUARE GRID (30-minute intervals)
            // Build index-to-DateTime mapping for continuous X-axis (removes weekend gaps)
            _indexToDateTime.Clear();
            for (int i = 0; i < _ohlcData.Candles.Count; i++)
            {
                _indexToDateTime.Add(_ohlcData.Candles[i].GetDateTime());
            }

            // Clear automatic ticks first
            plot.Axes.Bottom.TickGenerator = new ScottPlot.TickGenerators.NumericManual();

            // Generate custom ticks every 30 minutes (2 bars for M15)
            var customTicks = new List<ScottPlot.Tick>();
            int barInterval = 2; // Every 30 minutes (2 bars * 15 min = 30 min)
            DateTime? lastDate = null;

            for (int i = 0; i < _ohlcData.Candles.Count; i += barInterval)
            {
                var candle = _ohlcData.Candles[i];
                var dateTime = candle.GetDateTime();
                // USE SEQUENTIAL INDEX instead of OADate to eliminate weekend gaps
                double xPosition = i;

                // Format time: "HH:mm"
                string timeStr = dateTime.ToString("HH:mm");

                // Show date only at 00:00 (midnight) and indent it
                string dateStr = "";
                if (dateTime.Hour == 0 && dateTime.Minute == 0)
                {
                    if (lastDate == null || lastDate.Value.Date != dateTime.Date)
                    {
                        dateStr = $"                           |  {dateTime:MMMM dd, yyyy}"; // spaces for left indent
                        lastDate = dateTime;
                    }
                }

                string label = string.IsNullOrEmpty(dateStr) ? timeStr : $"{timeStr}\n{dateStr}";

                customTicks.Add(new ScottPlot.Tick(xPosition, label));
            }

            // Apply custom ticks
            var manualTickGen = (ScottPlot.TickGenerators.NumericManual)plot.Axes.Bottom.TickGenerator;
            for (int i = 0; i < customTicks.Count; i++)
            {
                manualTickGen.AddMajor(customTicks[i].Position, customTicks[i].Label);
            }

            // Customize tick label appearance
            plot.Axes.Bottom.TickLabelStyle.Rotation = 0;
            plot.Axes.Bottom.TickLabelStyle.FontSize = 9;
            plot.Axes.Bottom.TickLabelStyle.ForeColor = ScottPlot.Colors.White;
            plot.Axes.Bottom.TickLabelStyle.Alignment = ScottPlot.Alignment.UpperCenter;

            // Enable grid to match tick positions (creates square grid every 30 min)
            plot.Grid.MajorLineColor = ScottPlot.Color.FromHex("#111112");
            plot.Grid.MajorLineWidth = 1;

            // Ensure axis is visible
            plot.Axes.Bottom.IsVisible = true;
            plot.Axes.Bottom.Label.IsVisible = true;
        }

        private void InitializePlayback()
        {
            _playbackTimer = new DispatcherTimer();
            _playbackTimer.Tick += PlaybackTimer_Tick;
            UpdatePlaybackSpeed();

            // Set progress slider based on mode
            if (_isMultiPair && _globalTimeline.Count > 0)
            {
                ProgressSlider.Maximum = _globalTimeline.Count - 1;
            }
            else
            {
                ProgressSlider.Maximum = _ohlcData.Candles.Count - 1;
            }
            ProgressSlider.Value = 0;

            // Update progress text
            UpdateProgressText();
        }

        private void UpdateSymbolInfo()
        {
            SymbolText.Text = GetPairDisplayName(_ohlcData.Symbol);
            PeriodText.Text = $"{_ohlcData.StartDate} to {_ohlcData.EndDate}";
        }

        private void InitializeRightPanel()
        {
            // Initialize right panel controls
            WinsCountText.Text = "0";
            LossesCountText.Text = "0";
            TotalRText.Text = "0.00R";
            WinRateText.Text = "0%";

            // Clear active trade slots
            ActiveTrade1Text.Text = "[Empty]";
            ActiveTrade2Text.Text = "[Empty]";
            ActiveTrade3Text.Text = "[Empty]";
            ActiveTrade4Text.Text = "[Empty]";
            ActiveTrade5Text.Text = "[Empty]";

            // Initialize indicator displays
            RegimeText.Text = "N/A";
            EmaAlignmentText.Text = "N/A";
            CsmDiffText.Text = "N/A";
            RsiText.Text = "N/A";
            AdxText.Text = "N/A";
            CurrentPriceText.Text = "N/A";
        }

        private void PlaybackTimer_Tick(object sender, EventArgs e)
        {
            if (_isMultiPair && _globalTimeline.Count > 0)
            {
                // Multi-pair global timeline mode
                if (_globalTimelineIndex < _globalTimeline.Count - 1)
                {
                    _globalTimelineIndex++;
                    AdvanceGlobalTimeline(_globalTimelineIndex);
                }
                else
                {
                    // End of global timeline
                    StopPlayback();
                }
            }
            else if (_playbackMode == PlaybackMode.RealM1 && _m1DataLoaded && _ohlcData.M1Candles != null)
            {
                // M1 playback mode: advance through M1 bars
                if (_m1BarIndex < _ohlcData.M1Candles.Count - 1)
                {
                    _m1BarIndex++;
                    AdvanceToM1Bar(_m1BarIndex);
                }
                else
                {
                    // End of M1 data
                    StopPlayback();
                }
            }
            else
            {
                // Standard playback mode: advance through M15 bars
                if (_currentBarIndex < _ohlcData.Candles.Count - 1)
                {
                    _currentBarIndex++;
                    AdvanceToBar(_currentBarIndex);
                }
                else
                {
                    // End of data
                    StopPlayback();
                }
            }
        }

        private void AdvanceToBar(int barIndex)
        {
            if (barIndex < 0 || barIndex >= _ohlcData.Candles.Count)
                return;

            var currentCandle = _ohlcData.Candles[barIndex];
            var currentTime = currentCandle.GetDateTime();

            // Update active trades list
            UpdateActiveTrades(currentTime);

            // Render chart up to current bar
            RenderChartUpToBar(barIndex);

            // Update UI
            UpdateChartInfo(currentCandle, barIndex);

            // Update progress slider (programmatically)
            _isUpdatingSliderProgrammatically = true;
            ProgressSlider.Value = barIndex;
            _isUpdatingSliderProgrammatically = false;
        }

        private void AdvanceToM1Bar(int m1BarIndex)
        {
            if (m1BarIndex < 0 || m1BarIndex >= _ohlcData.M1Candles.Count)
                return;

            var currentM1Candle = _ohlcData.M1Candles[m1BarIndex];
            var currentTime = currentM1Candle.GetDateTime();

            // Find corresponding M15 bar index (15 M1 bars = 1 M15 bar)
            int correspondingM15Index = m1BarIndex / 15;

            // Update active trades based on M1 time
            UpdateActiveTrades(currentTime);

            // Render M1 chart up to current bar
            RenderM1ChartUpToBar(m1BarIndex);

            // Update UI with M1 candle data (use current M1 price)
            var displayCandle = new CandleData
            {
                Timestamp = currentM1Candle.Timestamp,
                Open = currentM1Candle.Open,
                High = currentM1Candle.High,
                Low = currentM1Candle.Low,
                Close = currentM1Candle.Close,
                // No indicators for M1
                EmaFast = null,
                EmaMid = null,
                EmaSlow = null,
                Rsi = null,
                Adx = null
            };

            UpdateChartInfo(displayCandle, correspondingM15Index);

            // Update progress slider based on M1 position (programmatically)
            _isUpdatingSliderProgrammatically = true;
            ProgressSlider.Value = m1BarIndex;
            _isUpdatingSliderProgrammatically = false;
        }

        private void AdvanceGlobalTimeline(int globalTimelineIndex)
        {
            if (globalTimelineIndex < 0 || globalTimelineIndex >= _globalTimeline.Count)
                return;

            var currentGlobalTime = _globalTimeline[globalTimelineIndex];

            // Check if any trades occur at this timestamp and auto-switch pairs if needed
            CheckAndSwitchPairForTradeEvents(currentGlobalTime);

            // Map global timestamp to bar index for current pair
            if (_pairTimelineMapping.ContainsKey(_currentPair) &&
                _pairTimelineMapping[_currentPair].ContainsKey(currentGlobalTime))
            {
                int barIndex = _pairTimelineMapping[_currentPair][currentGlobalTime];
                _currentBarIndex = barIndex;

                // Advance to this bar for current pair
                AdvanceToBar(barIndex);
            }

            // Update progress slider for global timeline (programmatically)
            _isUpdatingSliderProgrammatically = true;
            ProgressSlider.Value = globalTimelineIndex;
            _isUpdatingSliderProgrammatically = false;

            // Update timeline position indicator
            RenderTimelinePositionIndicator();
        }

        private void CheckAndSwitchPairForTradeEvents(DateTime currentTime)
        {
            if (_multiPairResults == null || _multiPairResults.Trades == null)
                return;

            // Find trades that open or close at this exact timestamp
            foreach (var trade in _multiPairResults.Trades)
            {
                var entryTime = DateTime.Parse(trade.EntryTime);
                DateTime? exitTime = string.IsNullOrEmpty(trade.ExitTime) ? (DateTime?)null : DateTime.Parse(trade.ExitTime);

                bool tradeEventOccurs = (entryTime == currentTime) || (exitTime.HasValue && exitTime.Value == currentTime);

                if (tradeEventOccurs && trade.Symbol != _currentPair)
                {
                    // Auto-switch to the pair where trade event occurs
                    System.Diagnostics.Debug.WriteLine($"[GLOBAL TIMELINE] Trade event at {currentTime:yyyy-MM-dd HH:mm} on {trade.Symbol}, switching from {_currentPair}");
                    SwitchToPairTab(trade.Symbol);
                    break; // Only switch once per tick
                }
            }
        }

        private void RenderM1ChartUpToBar(int maxM1BarIndex)
        {
            var plot = ChartPlot.Plot;

            // Clear previous plottables
            foreach (var plottable in _candlePlottables)
            {
                plot.Remove(plottable);
            }
            foreach (var plottable in _tradePlottables)
            {
                plot.Remove(plottable);
            }
            _candlePlottables.Clear();
            _tradePlottables.Clear();

            // Build animated M15 candles from M1 data
            var animatedM15Candles = BuildAnimatedM15Candles(maxM1BarIndex);
            System.Diagnostics.Debug.WriteLine($"[M1 RENDER] Before candlesticks - Bar {maxM1BarIndex}");
            var limitsBeforeCandles = plot.Axes.GetLimits();
            System.Diagnostics.Debug.WriteLine($"[M1 RENDER] Before candlesticks - Limits=[{limitsBeforeCandles.Left:F2}, {limitsBeforeCandles.Right:F2}]");

            RenderCandlesticks(plot, animatedM15Candles);

            var limitsAfterCandles = plot.Axes.GetLimits();
            System.Diagnostics.Debug.WriteLine($"[M1 RENDER] After candlesticks - Limits=[{limitsAfterCandles.Left:F2}, {limitsAfterCandles.Right:F2}] (changed: {limitsBeforeCandles != limitsAfterCandles})");

            // Find corresponding M15 index for indicators
            int correspondingM15Index = maxM1BarIndex / 15;

            // Render M15 indicators (EMAs still based on M15 timeframe)
            var visibleM15Candles = _ohlcData.Candles.Take(correspondingM15Index + 1).ToList();
            RenderIndicators(plot, visibleM15Candles);

            // Render trades up to current M15 bar
            RenderClosedTrades(plot, correspondingM15Index);
            RenderActiveTrades(plot, correspondingM15Index);

            // Auto-scale viewport during playback
            if (_isPlaying)
            {
                // ALWAYS update X-axis viewport during playback to prevent auto-scaling
                // Only update Y-axis when a new M15 bar completes (expensive operation)
                var currentIndex = maxM1BarIndex;
                var currentPrice = _ohlcData.M1Candles[maxM1BarIndex].Close;
                var currentLimits = plot.Axes.GetLimits();

                // Preserve user's manual zoom level (X-axis range)
                // Use saved limits if available (user paused with custom zoom)
                double currentXRange;
                if (_savedAxisLimits.HasValue)
                {
                    // Preserve the zoom level the user set
                    currentXRange = _savedAxisLimits.Value.Right - _savedAxisLimits.Value.Left;
                    System.Diagnostics.Debug.WriteLine($"[M1 PLAY] Using saved limits: XRange={currentXRange}");
                }
                else
                {
                    // Use current range from chart
                    currentXRange = currentLimits.Right - currentLimits.Left;
                    System.Diagnostics.Debug.WriteLine($"[M1 PLAY] Bar {currentIndex}: currentLimits=[{currentLimits.Left:F2}, {currentLimits.Right:F2}], XRange={currentXRange:F2}");
                }

                // Use default range only if range is genuinely invalid
                // Viewport is in M15 coordinates, NOT M1! Default: 1 day = 96 M15 bars
                // M1 is only used for smooth animation within M15 candle body
                if (currentXRange <= 0 || currentXRange > 35040)  // 365 days in M15 bars
                {
                    System.Diagnostics.Debug.WriteLine($"[M1 PLAY] DETECTED INVALID RANGE - Setting default 96 (M15 bars). XRange={currentXRange}");
                    currentXRange = 96.0; // 1 day default in M15 coordinates
                }

                // Position current bar at exactly 80% from left edge (80% past, 20% future)
                // CRITICAL: Convert M1 bar index to M15 equivalent since viewport is in M15 coordinates!
                // M1 is only used for smooth animation within M15 candle body
                // THIS RUNS EVERY FRAME to prevent ScottPlot auto-scaling
                double currentM15Index = currentIndex / 15.0;  // Convert M1 index to M15 equivalent
                double barPosition = currentM15Index - (currentXRange * 0.80);
                double xLeft = Math.Max(0, barPosition);
                double xRight = xLeft + currentXRange;
                System.Diagnostics.Debug.WriteLine($"[M1 PLAY] Bar {currentIndex} (M15: {currentM15Index:F2}): barPos={barPosition:F2}, xLeft={xLeft:F2}, xRight={xRight:F2}, Setting limits=[{xLeft:F2}, {xRight:F2}]");
                plot.Axes.SetLimitsX(xLeft, xRight);

                // Smart Y-axis following: only follow on new M15 bar completion to reduce flicker
                bool isNewM15Bar = (maxM1BarIndex % 15 == 14) || (maxM1BarIndex == _ohlcData.M1Candles.Count - 1);
                if (isNewM15Bar)
                {
                    bool shouldFollow = ShouldFollowPrice(currentPrice, currentLimits.Bottom, currentLimits.Top);

                    if (shouldFollow || currentLimits.Bottom == 0) // Follow if needed or if initial state
                    {
                        // Preserve the current Y-axis range (zoom level)
                        double currentYRange = currentLimits.Top - currentLimits.Bottom;

                        // Use default range only on initial load (when Bottom is 0)
                        if (currentLimits.Bottom == 0)
                        {
                            currentYRange = _ohlcData.PipSize * 100; // 100 pips default
                        }

                        // Center the viewport on current price while preserving zoom level
                        plot.Axes.SetLimitsY(currentPrice - currentYRange / 2, currentPrice + currentYRange / 2);
                    }
                    // else: keep current Y-axis limits (price is in safe zone)
                }
            }
            else if (_savedAxisLimits.HasValue)
            {
                plot.Axes.SetLimits(_savedAxisLimits.Value);
            }
            else
            {
                // Initial viewport: 100 pips vertical, 1 day horizontal
                var currentIndex = maxM1BarIndex;
                var currentPrice = _ohlcData.M1Candles[maxM1BarIndex].Close;

                // Set X-axis: show 1 day in M15 coordinates (96 M15 bars, NOT 1440 M1 bars!)
                // CRITICAL: Viewport is in M15 coordinates. M1 is only for smooth animation.
                // Position current bar at 80% from left (80% past, 20% future)
                double barRange = 96.0; // 1 day in M15 bars (NOT 1440 M1 bars)
                double currentM15Index = currentIndex / 15.0;  // Convert M1 index to M15 equivalent
                double barPosition = currentM15Index - (barRange * 0.80);
                double xLeft = Math.Max(0, barPosition);
                double xRight = xLeft + barRange;
                System.Diagnostics.Debug.WriteLine($"[M1 INIT] Bar {currentIndex} (M15: {currentM15Index:F2}): NOT PLAYING - Setting limits=[{xLeft:F2}, {xRight:F2}]");
                plot.Axes.SetLimitsX(xLeft, xRight);

                // Set Y-axis: 100 pips range centered on current price
                var defaultYRange = _ohlcData.PipSize * 100; // 100 pips
                plot.Axes.SetLimitsY(currentPrice - defaultYRange / 2, currentPrice + defaultYRange / 2);
            }

            var afterLimits = plot.Axes.GetLimits();
            System.Diagnostics.Debug.WriteLine($"[M1 RENDER] AFTER REFRESH - Limits=[{afterLimits.Left:F2}, {afterLimits.Right:F2}], Range={afterLimits.Right - afterLimits.Left:F2}");
            ChartPlot.Refresh();
        }

        private List<CandleData> BuildAnimatedM15Candles(int maxM1BarIndex)
        {
            var m15Candles = new List<CandleData>();

            // Group M1 bars into 15-minute periods
            int totalM15Candles = (maxM1BarIndex / 15) + 1; // +1 for the forming candle

            for (int m15Index = 0; m15Index < totalM15Candles; m15Index++)
            {
                int startM1Index = m15Index * 15;
                int endM1Index = Math.Min(startM1Index + 14, maxM1BarIndex); // Don't go beyond current bar

                // Get M1 bars for this 15-minute period
                var m1BarsInPeriod = _ohlcData.M1Candles
                    .Skip(startM1Index)
                    .Take(endM1Index - startM1Index + 1)
                    .ToList();

                if (m1BarsInPeriod.Count == 0)
                    continue;

                // Build M15 candle from M1 data
                var firstM1 = m1BarsInPeriod.First();
                var lastM1 = m1BarsInPeriod.Last();

                var m15Candle = new CandleData
                {
                    Timestamp = firstM1.Timestamp,
                    Open = firstM1.Open,
                    High = m1BarsInPeriod.Max(c => c.High),
                    Low = m1BarsInPeriod.Min(c => c.Low),
                    Close = lastM1.Close,
                    // Use M15 indicators if available for completed candles
                    EmaFast = null,
                    EmaMid = null,
                    EmaSlow = null,
                    Rsi = null,
                    Adx = null
                };

                // If this M15 candle corresponds to an actual M15 bar, use its indicators
                if (m15Index < _ohlcData.Candles.Count)
                {
                    var originalM15 = _ohlcData.Candles[m15Index];
                    m15Candle.EmaFast = originalM15.EmaFast;
                    m15Candle.EmaMid = originalM15.EmaMid;
                    m15Candle.EmaSlow = originalM15.EmaSlow;
                    m15Candle.Rsi = originalM15.Rsi;
                    m15Candle.Adx = originalM15.Adx;
                }

                m15Candles.Add(m15Candle);
            }

            return m15Candles;
        }

        private bool ShouldFollowPrice(double currentPrice, double yMin, double yMax)
        {
            // Calculate price position as percentage of visible Y-axis range
            double range = yMax - yMin;
            if (range == 0) return true; // Safety check

            double pricePositionPercent = ((currentPrice - yMin) / range) * 100.0;

            // Follow price if it's outside the middle 35% zone
            // Middle 35% means: 32.5% from bottom to 67.5% from bottom
            bool outsideMiddleZone = pricePositionPercent < 32.5 || pricePositionPercent > 67.5;

            return outsideMiddleZone;
        }

        private void UpdateActiveTrades(DateTime currentTime)
        {
            // Check for new trade entries
            foreach (var trade in _ohlcData.Trades)
            {
                var entryTime = trade.GetEntryTime();
                var exitTime = trade.GetExitTime();

                // Check if trade enters at current time
                if (entryTime == currentTime && !_activeTrades.Contains(trade))
                {
                    _activeTrades.Add(trade);
                }

                // Check if trade exits at current time
                if (exitTime.HasValue && exitTime.Value == currentTime && _activeTrades.Contains(trade))
                {
                    _activeTrades.Remove(trade);

                    // Update cumulative R
                    if (trade.RMultiple.HasValue)
                    {
                        _cumulativeR += trade.RMultiple.Value;

                        // Track wins/losses
                        if (trade.IsWin)
                            _winsCount++;
                        else
                            _lossesCount++;
                    }

                    // Refresh Recent Trades list (Enhancement #1)
                    PopulateRecentTradesList();
                }
            }
        }

        private void RenderChartUpToBar(int maxBarIndex)
        {
            var plot = ChartPlot.Plot;

            // Clear previous plottables
            foreach (var plottable in _candlePlottables)
            {
                plot.Remove(plottable);
            }
            foreach (var plottable in _tradePlottables)
            {
                plot.Remove(plottable);
            }
            _candlePlottables.Clear();
            _tradePlottables.Clear();

            // Render candles up to current bar
            var visibleCandles = _ohlcData.Candles.Take(maxBarIndex + 1).ToList();
            RenderCandlesticks(plot, visibleCandles);

            // Render indicators
            RenderIndicators(plot, visibleCandles);

            // Render closed trades up to current bar
            RenderClosedTrades(plot, maxBarIndex);

            // Render active trades
            RenderActiveTrades(plot, maxBarIndex);

            // Auto-scale viewport to follow current price during playback
            if (_isPlaying)
            {
                var currentIndex = maxBarIndex;
                var currentPrice = _ohlcData.Candles[maxBarIndex].Close;
                var currentLimits = plot.Axes.GetLimits();

                // Preserve user's manual zoom level (X-axis range)
                // Use saved limits if available (user paused with custom zoom)
                double currentXRange;
                if (_savedAxisLimits.HasValue)
                {
                    // Preserve the zoom level the user set
                    currentXRange = _savedAxisLimits.Value.Right - _savedAxisLimits.Value.Left;
                }
                else
                {
                    // Use current range from chart
                    currentXRange = currentLimits.Right - currentLimits.Left;
                }

                // Use default range only if range is genuinely invalid
                // Don't reset just because Left==0 (chart can legitimately be at bar 0)
                // 1 day = 96 M15 bars, max reasonable zoom = 365 days = 35040 bars
                if (currentXRange <= 0 || currentXRange > 35040)
                {
                    currentXRange = 96.0; // 1 day default (96 M15 bars)
                }

                // Position current bar at exactly 80% from left edge (80% past, 20% future)
                double barPosition = currentIndex - (currentXRange * 0.80);
                double xLeft = Math.Max(0, barPosition);
                double xRight = xLeft + currentXRange;
                plot.Axes.SetLimitsX(xLeft, xRight);

                // Smart Y-axis following: only follow if price moves outside middle 35% zone
                bool shouldFollow = ShouldFollowPrice(currentPrice, currentLimits.Bottom, currentLimits.Top);

                if (shouldFollow || currentLimits.Bottom == 0) // Follow if needed or if initial state
                {
                    // Preserve the current Y-axis range (zoom level)
                    double currentYRange = currentLimits.Top - currentLimits.Bottom;

                    // Use default range only on initial load (when Bottom is 0)
                    if (currentLimits.Bottom == 0)
                    {
                        currentYRange = _ohlcData.PipSize * 100; // 100 pips default
                    }

                    // Center the viewport on current price while preserving zoom level
                    plot.Axes.SetLimitsY(currentPrice - currentYRange / 2, currentPrice + currentYRange / 2);
                }
                // else: keep current Y-axis limits (price is in safe zone)
            }
            else if (_savedAxisLimits.HasValue)
            {
                // When paused, maintain saved viewport position
                plot.Axes.SetLimits(_savedAxisLimits.Value);
            }
            else
            {
                // Initial viewport: 100 pips vertical, 1 day horizontal
                var currentIndex = maxBarIndex;
                var currentPrice = _ohlcData.Candles[maxBarIndex].Close;

                // Set X-axis: show 1 day of M15 candles (96 bars = 24 hours)
                // Position current bar at 80% from left (80% past, 20% future)
                double barRange = 96.0; // 1 day = 96 M15 bars
                double barPosition = currentIndex - (barRange * 0.80);
                double xLeft = Math.Max(0, barPosition);
                double xRight = xLeft + barRange;
                plot.Axes.SetLimitsX(xLeft, xRight);

                // Set Y-axis: 100 pips range centered on current price
                var defaultYRange = _ohlcData.PipSize * 100; // 100 pips
                plot.Axes.SetLimitsY(currentPrice - defaultYRange / 2, currentPrice + defaultYRange / 2);
            }
            ChartPlot.Refresh();
        }

        private void RenderCandlesticks(Plot plot, List<CandleData> candles)
        {
            if (candles.Count == 0) return;

            var ohlcList = new List<OHLC>();
            for (int i = 0; i < candles.Count; i++)
            {
                var candle = candles[i];
                // USE SEQUENTIAL INDEX for X position to eliminate weekend gaps
                // Convert index to OADate-compatible DateTime: index i â†’ OADate i
                var ohlc = new OHLC(
                    candle.Open,
                    candle.High,
                    candle.Low,
                    candle.Close,
                    // FromOADate converts: 0 â†’ Dec 30 1899, 1 â†’ Dec 31 1899, etc.
                    // This aligns with sequential tick indices (0, 1, 2...)
                    DateTime.FromOADate(i),
                    // TimeSpan represents candle width: 0.8 days gives visible bodies with spacing
                    // (X-axis uses sequential integers, so 1 unit = 1 bar spacing)
                    TimeSpan.FromDays(0.8)
                );
                ohlcList.Add(ohlc);
            }

            // Add candlestick chart with sequential indices for X coordinates
            var ohlcArray = ohlcList.ToArray();
            var candlestickPlot = plot.Add.Candlestick(ohlcArray);

            _candlePlottables.Add(candlestickPlot);
        }

        private void RenderIndicators(Plot plot, List<CandleData> candles)
        {
            if (candles.Count == 0) return;

            // Render M15 EMAs (if enabled)
            if (_showM15Emas)
            {
                RenderEmaSet(plot, candles,
                    c => c.Ema20_M15, c => c.Ema50_M15, c => c.Ema100_M15,
                    "M15", LinePattern.Solid, 1.5f);
            }

            // Render H1 EMAs (if enabled)
            if (_showH1Emas)
            {
                RenderEmaSet(plot, candles,
                    c => c.Ema20_H1, c => c.Ema50_H1, c => c.Ema100_H1,
                    "H1", LinePattern.Dashed, 2.0f);
            }
        }

        private void RenderEmaSet(Plot plot, List<CandleData> candles,
            Func<CandleData, double?> ema20Selector,
            Func<CandleData, double?> ema50Selector,
            Func<CandleData, double?> ema100Selector,
            string timeframeLabel,
            LinePattern linePattern,
            float lineWidth)
        {
            // DEBUG: Check EMA availability
            int totalCandles = candles.Count;
            int ema20Count = candles.Count(c => ema20Selector(c).HasValue);
            if (ENABLE_VERBOSE_DEBUG)
                System.Diagnostics.Debug.WriteLine($"[RenderEmaSet {timeframeLabel}] Total candles: {totalCandles}, EMA20 count: {ema20Count}");

            // EMA 20 - collect values AND their corresponding timestamps (filter out NaN/Infinity)
            var ema20Data = candles
                .Select((c, i) => new { Index = i, Value = ema20Selector(c), Candle = c })
                .Where(x => x.Value.HasValue && !double.IsNaN(x.Value.Value) && !double.IsInfinity(x.Value.Value))
                .ToList();

            if (ENABLE_VERBOSE_DEBUG)
                System.Diagnostics.Debug.WriteLine($"[RenderEmaSet {timeframeLabel}] EMA20 data points after filtering: {ema20Data.Count}");

            if (ema20Data.Count > 0)
            {
                // USE SEQUENTIAL INDEX instead of ToOADate() to eliminate weekend gaps
                var xs = ema20Data.Select(x => (double)x.Index).ToArray();
                var ys = ema20Data.Select(x => x.Value.Value).ToArray();
                var line20 = plot.Add.ScatterLine(xs, ys);
                line20.Color = ScottPlot.Color.FromHex("#EF5350"); // RED
                line20.LineWidth = lineWidth;
                line20.LinePattern = linePattern;
                line20.LegendText = $"{timeframeLabel} EMA 20";
                _candlePlottables.Add(line20);
            }

            // EMA 50 - collect values AND their corresponding timestamps (filter out NaN/Infinity)
            var ema50Data = candles
                .Select((c, i) => new { Index = i, Value = ema50Selector(c), Candle = c })
                .Where(x => x.Value.HasValue && !double.IsNaN(x.Value.Value) && !double.IsInfinity(x.Value.Value))
                .ToList();

            if (ema50Data.Count > 0)
            {
                // USE SEQUENTIAL INDEX instead of ToOADate() to eliminate weekend gaps
                var xs = ema50Data.Select(x => (double)x.Index).ToArray();
                var ys = ema50Data.Select(x => x.Value.Value).ToArray();
                var line50 = plot.Add.ScatterLine(xs, ys);
                line50.Color = ScottPlot.Color.FromHex("#FF6D00"); // ORANGE
                line50.LineWidth = lineWidth;
                line50.LinePattern = linePattern;
                line50.LegendText = $"{timeframeLabel} EMA 50";
                _candlePlottables.Add(line50);
            }

            // EMA 100 - collect values AND their corresponding timestamps (filter out NaN/Infinity)
            var ema100Data = candles
                .Select((c, i) => new { Index = i, Value = ema100Selector(c), Candle = c })
                .Where(x => x.Value.HasValue && !double.IsNaN(x.Value.Value) && !double.IsInfinity(x.Value.Value))
                .ToList();

            if (ema100Data.Count > 0)
            {
                // USE SEQUENTIAL INDEX instead of ToOADate() to eliminate weekend gaps
                var xs = ema100Data.Select(x => (double)x.Index).ToArray();
                var ys = ema100Data.Select(x => x.Value.Value).ToArray();
                var line100 = plot.Add.ScatterLine(xs, ys);
                line100.Color = ScottPlot.Color.FromHex("#2962FF"); // BLUE
                line100.LineWidth = lineWidth;
                line100.LinePattern = linePattern;
                line100.LegendText = $"{timeframeLabel} EMA 100";
                _candlePlottables.Add(line100);
            }
        }

        // Helper method: Convert DateTime to sequential bar index
        private int GetBarIndexForDateTime(DateTime dateTime)
        {
            // Find the closest bar index for the given DateTime
            for (int i = 0; i < _indexToDateTime.Count; i++)
            {
                if (_indexToDateTime[i] >= dateTime)
                    return i;
            }
            return _indexToDateTime.Count - 1;
        }

        private void RenderClosedTrades(Plot plot, int currentBarIndex)
        {
            var currentTime = _ohlcData.Candles[currentBarIndex].GetDateTime();

            foreach (var trade in _ohlcData.Trades)
            {
                var exitTime = trade.GetExitTime();
                if (!exitTime.HasValue || exitTime.Value > currentTime)
                    continue;

                // USE SEQUENTIAL INDEX instead of ToOADate() to eliminate weekend gaps
                var entryIndex = GetBarIndexForDateTime(trade.GetEntryTime());
                var exitIndex = GetBarIndexForDateTime(exitTime.Value);

                // Draw line from entry to exit using sequential indices
                var color = trade.IsWin
                    ? ScottPlot.Color.FromHex("#00FF00") // Green for wins
                    : ScottPlot.Color.FromHex("#FF0000"); // Red for losses

                var line = plot.Add.Line(entryIndex, trade.EntryPrice, exitIndex, trade.ExitPrice.Value);
                line.Color = color;
                line.LineWidth = 2;
                line.LinePattern = LinePattern.Dashed;

                _tradePlottables.Add(line);

                // Add label at exit point using sequential index
                var label = plot.Add.Text(
                    $"#{trade.TicketNumber} {trade.RMultiple:+0.00}R",
                    exitIndex,
                    trade.ExitPrice.Value
                );
                label.LabelFontColor = ScottPlot.Color.FromHex("#FFFFFF");
                label.LabelFontSize = 10;

                _tradePlottables.Add(label);
            }
        }

        private void RenderActiveTrades(Plot plot, int currentBarIndex)
        {
            if (_activeTrades.Count == 0)
                return;

            var currentCandle = _ohlcData.Candles[currentBarIndex];
            var currentPrice = currentCandle.Close;

            foreach (var trade in _activeTrades)
            {
                // USE SEQUENTIAL INDEX instead of ToOADate() to eliminate weekend gaps
                var entryIndex = GetBarIndexForDateTime(trade.GetEntryTime());

                // Calculate offset for labels (subtract bar count)
                var labelOffset3Bars = 3;
                var labelOffset5Bars = 5;

                // Draw entry marker using sequential index
                var marker = plot.Add.Marker(entryIndex, trade.EntryPrice);
                marker.Color = ScottPlot.Color.FromHex("#FFFF00"); // Yellow
                marker.Size = 8;
                marker.Shape = MarkerShape.FilledCircle;
                _tradePlottables.Add(marker);

                // DEBUG: Draw Entry price as horizontal line
                var entryLine = plot.Add.HorizontalLine(trade.EntryPrice);
                entryLine.Color = ScottPlot.Color.FromHex("#FFFFFF");
                entryLine.LineWidth = 1;
                entryLine.LinePattern = LinePattern.Dashed;
                _tradePlottables.Add(entryLine);

                // DEBUG: Draw TP as horizontal line instead of box
                if (trade.TakeProfit.HasValue)
                {
                    // TP horizontal line
                    var tpLine = plot.Add.HorizontalLine(trade.TakeProfit.Value);
                    tpLine.Color = ScottPlot.Color.FromHex("#00FF00");
                    tpLine.LineWidth = 1;
                    tpLine.LinePattern = LinePattern.Solid;
                    _tradePlottables.Add(tpLine);

                    // TP label
                    int pipsToTP = trade.GetPipsToTP(_ohlcData.PipSize);
                    var tpLabel = plot.Add.Text(
                        $"TP: {trade.TakeProfit.Value:F5} (+{Math.Abs(pipsToTP)} pips)",
                        entryIndex - labelOffset3Bars,
                        trade.TakeProfit.Value
                    );
                    tpLabel.LabelFontColor = ScottPlot.Color.FromHex("#00FF00");
                    tpLabel.LabelFontSize = 10;
                    tpLabel.LabelBold = true;
                    _tradePlottables.Add(tpLabel);
                }

                // DEBUG: Draw SL as horizontal line instead of box
                if (trade.StopLoss.HasValue)
                {
                    // SL horizontal line
                    var slLine = plot.Add.HorizontalLine(trade.StopLoss.Value);
                    slLine.Color = ScottPlot.Color.FromHex("#FF0000");
                    slLine.LineWidth = 1;
                    slLine.LinePattern = LinePattern.Solid;
                    _tradePlottables.Add(slLine);

                    // SL label
                    int pipsToSL = trade.GetPipsToSL(_ohlcData.PipSize);
                    var slLabel = plot.Add.Text(
                        $"SL: {trade.StopLoss.Value:F5}\n-{Math.Abs(pipsToSL)} pips",
                        entryIndex - labelOffset5Bars,
                        trade.StopLoss.Value
                    );
                    slLabel.LabelFontColor = ScottPlot.Color.FromHex("#FF0000");
                    slLabel.LabelFontSize = 10;
                    _tradePlottables.Add(slLabel);
                }

                // Draw live R-multiple
                //double liveR = trade.GetLiveRMultiple(currentPrice);
               // var rLabel = plot.Add.Text(
                   // $"#{trade.TicketNumber} {trade.Strategy}\nLive: {liveR:+0.00}R",
                   // entryTime,
                   // trade.EntryPrice + 0.0020
               // );
               // rLabel.LabelFontColor = liveR >= 0
                //    ? ScottPlot.Color.FromHex("#00FF00")
                //    : ScottPlot.Color.FromHex("#FF0000");
               // rLabel.LabelFontSize = 10;
              //  _tradePlottables.Add(rLabel);
            }
        }

        private int FindBarIndex(DateTime time)
        {
            for (int i = 0; i < _ohlcData.Candles.Count; i++)
            {
                if (_ohlcData.Candles[i].GetDateTime() == time)
                    return i;
            }
            return -1;
        }

        private void UpdateChartInfo(CandleData candle, int barIndex)
        {
            // Update bottom panel date/time and active trades count
            CurrentTimeText.Text = candle.GetDateTime().ToString("dd MMM yyyy  HH:mm");
            ActiveTradesText.Text = _activeTrades.Count.ToString();

            // Update right panel - Performance Summary
            WinsCountText.Text = _winsCount.ToString();
            LossesCountText.Text = _lossesCount.ToString();
            TotalRText.Text = $"{_cumulativeR:+0.00}R";

            int totalTrades = _winsCount + _lossesCount;
            double winRate = totalTrades > 0 ? (_winsCount * 100.0 / totalTrades) : 0;
            WinRateText.Text = $"{winRate:F1}%";

            // Phase 8.2.4: Update right panel - Active Trade Slots (up to 5) with click support
            var activeTradeTexts = new[] { ActiveTrade1Text, ActiveTrade2Text, ActiveTrade3Text, ActiveTrade4Text, ActiveTrade5Text };
            var activeTradeBorders = new[] { ActiveTrade1Border, ActiveTrade2Border, ActiveTrade3Border, ActiveTrade4Border, ActiveTrade5Border };

            for (int i = 0; i < activeTradeTexts.Length; i++)
            {
                if (i < _activeTrades.Count)
                {
                    var trade = _activeTrades[i];
                    double liveR = trade.GetLiveRMultiple(candle.Close);

                    // Include symbol for multi-pair mode
                    string symbolDisplay = _isMultiPair ? $"{trade.Symbol} " : "";
                    activeTradeTexts[i].Text = $"{symbolDisplay}#{trade.TicketNumber} {trade.Side}\n" +
                                               $"@ {trade.EntryPrice:F5} | {liveR:+0.0;-0.0}R\n" +
                                               $"{trade.Strategy} | {(trade.IsWin ? "WIN" : "OPEN")}";

                    activeTradeTexts[i].Foreground = liveR >= 0
                        ? new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(0, 170, 0))
                        : new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 68, 68));

                    // Store trade reference and make clickable
                    activeTradeBorders[i].Tag = trade;
                    activeTradeBorders[i].Cursor = System.Windows.Input.Cursors.Hand;
                }
                else
                {
                    activeTradeTexts[i].Text = "[Empty]";
                    activeTradeTexts[i].Foreground = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(136, 136, 136));

                    // Clear trade reference and reset cursor
                    activeTradeBorders[i].Tag = null;
                    activeTradeBorders[i].Cursor = System.Windows.Input.Cursors.Arrow;
                }
            }

            // Update right panel - Indicators
            CurrentPriceText.Text = candle.Close.ToString("F5");
            RsiText.Text = candle.Rsi.HasValue ? candle.Rsi.Value.ToString("F1") : "N/A";
            AdxText.Text = candle.Adx.HasValue ? candle.Adx.Value.ToString("F1") : "N/A";

            // EMA Alignment
            if (candle.EmaFast.HasValue && candle.EmaMid.HasValue && candle.EmaSlow.HasValue)
            {
                bool bullish = candle.EmaFast > candle.EmaMid && candle.EmaMid > candle.EmaSlow;
                bool bearish = candle.EmaFast < candle.EmaMid && candle.EmaMid < candle.EmaSlow;
                EmaAlignmentText.Text = bullish ? "Bullish" : (bearish ? "Bearish" : "Mixed");
            }
            else
            {
                EmaAlignmentText.Text = "N/A";
            }

            // CSM Differential (would need to be added to candle data)
            CsmDiffText.Text = "N/A";  // TODO: Add CSM diff to candle data

            // Regime (would need to be added to candle data)
            RegimeText.Text = "N/A";  // TODO: Add regime to candle data

            UpdateProgressText();
        }

        private void UpdateProgressText()
        {
            if (_playbackMode == PlaybackMode.RealM1 && _m1DataLoaded && _ohlcData.M1Candles != null)
            {
                // M1 playback mode
                ProgressText.Text = $"M1 Bar: {_m1BarIndex + 1} / {_ohlcData.M1Candles.Count}";
                double percent = _ohlcData.M1Candles.Count > 0
                    ? (_m1BarIndex * 100.0 / (_ohlcData.M1Candles.Count - 1))
                    : 0;
                ProgressPercent.Text = $"{percent:F1}%";
            }
            else
            {
                // Standard M15 playback mode
                ProgressText.Text = $"M15 Bar: {_currentBarIndex + 1} / {_ohlcData.Candles.Count}";
                double percent = _ohlcData.Candles.Count > 0
                    ? (_currentBarIndex * 100.0 / (_ohlcData.Candles.Count - 1))
                    : 0;
                ProgressPercent.Text = $"{percent:F1}%";
            }
        }

        private void UpdatePlaybackSpeed()
        {
            double speed = SpeedSlider.Value;

            // Calculate bars per second based on playback mode
            double barsPerSec = _playbackMode == PlaybackMode.RealM1
                ? speed * 15.0  // M1 mode: 15 bars/sec at 1x (15 M1 bars = 1 M15 bar)
                : speed * 1.0;  // M15 mode: 1 bar/sec at 1x

            SpeedText.Text = $"{speed:F1}x ({barsPerSec:F1} bars/sec)";

            // Base interval: 1000ms for M15, 66ms for M1 (to get 15 bars/sec at 1x)
            int baseInterval = _playbackMode == PlaybackMode.RealM1 ? 66 : 1000;

            // Apply speed multiplier
            int interval = Math.Max(1, (int)(baseInterval / speed));

            _playbackTimer.Interval = TimeSpan.FromMilliseconds(interval);
        }

        private void SpeedSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            // Update playback speed when slider changes
            if (_playbackTimer != null)
            {
                UpdatePlaybackSpeed();
            }
        }

        private async void LoadM1DataAsync(string taskId)
        {
            try
            {
                // Update title to show loading
                this.Title = $"{GetPairDisplayName(_ohlcData.Symbol)} - Loading M1 Data...";

                // Load M1 data from API
                var apiClient = new BacktestApiClient();
                var m1Data = await apiClient.GetOhlcM1DataAsync(taskId);

                if (m1Data != null && m1Data.Candles != null && m1Data.Candles.Count > 0)
                {
                    _ohlcData.M1Candles = m1Data.Candles;
                    _m1DataLoaded = true;
                    _playbackMode = PlaybackMode.RealM1;

                    // Update title to show M1 mode is active
                    this.Title = $"{GetPairDisplayName(_ohlcData.Symbol)} - M1 Playback Mode ({m1Data.Candles.Count} bars)";

                    // Update playback speed to account for M1 mode
                    UpdatePlaybackSpeed();

                    // Update progress slider for M1 mode
                    ProgressSlider.Maximum = _ohlcData.M1Candles.Count - 1;
                    UpdateProgressText();

                    MessageBox.Show(
                        $"M1 Playback Mode Activated!\n\n" +
                        $"Loaded {m1Data.Candles.Count:N0} M1 bars\n" +
                        $"This provides 15x smoother playback than M15.\n\n" +
                        $"Press Play to see the difference!",
                        "M1 Data Loaded",
                        MessageBoxButton.OK,
                        MessageBoxImage.Information);
                }
                else
                {
                    _m1DataLoaded = false;
                    _playbackMode = PlaybackMode.Standard;
                    this.Title = $"{GetPairDisplayName(_ohlcData.Symbol)} - Standard M15 Playback";

                    MessageBox.Show(
                        "M1 data not available.\n\nUsing standard M15 playback mode.",
                        "M1 Data Unavailable",
                        MessageBoxButton.OK,
                        MessageBoxImage.Warning);
                }
            }
            catch (Exception ex)
            {
                _m1DataLoaded = false;
                _playbackMode = PlaybackMode.Standard;
                this.Title = $"{GetPairDisplayName(_ohlcData.Symbol)} - Standard M15 Playback";

                MessageBox.Show(
                    $"Failed to load M1 data:\n\n{ex.Message}\n\nUsing standard M15 playback mode.",
                    "M1 Data Load Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
            }
        }

        private void StartPlayback()
        {
            _isPlaying = true;
            _playbackTimer.Start();
            PlayPauseButton.Content = "Pause";
        }

        private void StopPlayback()
        {
            _isPlaying = false;
            _playbackTimer.Stop();
            PlayPauseButton.Content = "Play";

            // Save current viewport so it's restored when resuming
            _savedAxisLimits = ChartPlot.Plot.Axes.GetLimits();
        }

        private void ReplayTradesUpToBar(int targetBarIndex)
        {
            // Recalculate cumulative R, wins, and losses up to the target bar
            var targetTime = _ohlcData.Candles[targetBarIndex].GetDateTime();

            foreach (var trade in _ohlcData.Trades)
            {
                var exitTime = trade.GetExitTime();
                if (exitTime.HasValue && exitTime.Value <= targetTime && trade.RMultiple.HasValue)
                {
                    _cumulativeR += trade.RMultiple.Value;
                    if (trade.IsWin)
                        _winsCount++;
                    else
                        _lossesCount++;
                }
            }
        }

        private void ReplayTradesUpToM1Bar(int targetM1BarIndex)
        {
            // Recalculate cumulative R, wins, and losses up to the target M1 bar
            var targetTime = _ohlcData.M1Candles[targetM1BarIndex].GetDateTime();

            foreach (var trade in _ohlcData.Trades)
            {
                var exitTime = trade.GetExitTime();
                if (exitTime.HasValue && exitTime.Value <= targetTime && trade.RMultiple.HasValue)
                {
                    _cumulativeR += trade.RMultiple.Value;
                    if (trade.IsWin)
                        _winsCount++;
                    else
                        _lossesCount++;
                }
            }
        }

        private void ReplayTradesUpToGlobalTime(int globalTimelineIndex)
        {
            // Recalculate cumulative R, wins, and losses up to the target global timeline position
            if (globalTimelineIndex < 0 || globalTimelineIndex >= _globalTimeline.Count)
                return;

            var targetTime = _globalTimeline[globalTimelineIndex];

            if (_multiPairResults == null || _multiPairResults.Trades == null)
                return;

            foreach (var trade in _multiPairResults.Trades)
            {
                DateTime? exitTime = string.IsNullOrEmpty(trade.ExitTime) ? (DateTime?)null : DateTime.Parse(trade.ExitTime);

                if (exitTime.HasValue && exitTime.Value <= targetTime && trade.RMultiple.HasValue)
                {
                    _cumulativeR += trade.RMultiple.Value;
                    bool isWin = (trade.RMultiple ?? 0) > 0;
                    if (isWin)
                        _winsCount++;
                    else
                        _lossesCount++;
                }
            }
        }

        // Event Handlers
        private void PlayPauseButton_Click(object sender, RoutedEventArgs e)
        {
            if (_isPlaying)
            {
                StopPlayback();
            }
            else
            {
                StartPlayback();
            }
        }

        private void ResetButton_Click(object sender, RoutedEventArgs e)
        {
            StopPlayback();

            // Reset indices based on playback mode
            _currentBarIndex = 0;
            _m1BarIndex = 0;
            _globalTimelineIndex = 0;

            // Reset statistics
            _cumulativeR = 0.0;
            _winsCount = 0;
            _lossesCount = 0;
            _activeTrades.Clear();
            _savedAxisLimits = null; // Reset viewport

            // Advance to first position based on playback mode
            if (_isMultiPair && _globalTimeline.Count > 0)
            {
                AdvanceGlobalTimeline(0);
            }
            else if (_playbackMode == PlaybackMode.RealM1 && _m1DataLoaded && _ohlcData.M1Candles != null)
            {
                AdvanceToM1Bar(0);
            }
            else
            {
                AdvanceToBar(0);
            }
        }

        private void ProgressSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            // Ignore programmatic updates (only respond to user interaction)
            if (_isUpdatingSliderProgrammatically)
                return;

            // Only allow manual scrubbing when not playing
            if (!_isPlaying)
            {
                int newIndex = (int)ProgressSlider.Value;

                // Handle based on playback mode
                if (_isMultiPair && _globalTimeline.Count > 0)
                {
                    // Multi-pair global timeline mode
                    if (newIndex != _globalTimelineIndex && newIndex >= 0 && newIndex < _globalTimeline.Count)
                    {
                        // Reset state and advance to new global timeline position
                        _cumulativeR = 0.0;
                        _winsCount = 0;
                        _lossesCount = 0;
                        _activeTrades.Clear();
                        _savedAxisLimits = null; // Reset viewport when manually scrubbing
                        _globalTimelineIndex = newIndex;

                        // Replay trades up to this point
                        ReplayTradesUpToGlobalTime(_globalTimelineIndex);

                        AdvanceGlobalTimeline(_globalTimelineIndex);
                    }
                }
                else if (_playbackMode == PlaybackMode.RealM1 && _m1DataLoaded && _ohlcData.M1Candles != null)
                {
                    // M1 playback mode
                    if (newIndex != _m1BarIndex && newIndex >= 0 && newIndex < _ohlcData.M1Candles.Count)
                    {
                        // Reset state and advance to new M1 position
                        _cumulativeR = 0.0;
                        _winsCount = 0;
                        _lossesCount = 0;
                        _activeTrades.Clear();
                        _savedAxisLimits = null; // Reset viewport when manually scrubbing
                        _m1BarIndex = newIndex;

                        // Replay trades up to this point
                        ReplayTradesUpToM1Bar(_m1BarIndex);

                        AdvanceToM1Bar(_m1BarIndex);
                    }
                }
                else
                {
                    // Standard M15 playback mode
                    if (newIndex != _currentBarIndex && newIndex >= 0 && newIndex < _ohlcData.Candles.Count)
                    {
                        // Reset state and advance to new M15 position
                        _cumulativeR = 0.0;
                        _winsCount = 0;
                        _lossesCount = 0;
                        _activeTrades.Clear();
                        _savedAxisLimits = null; // Reset viewport when manually scrubbing
                        _currentBarIndex = newIndex;

                        // Replay trades up to this point
                        ReplayTradesUpToBar(_currentBarIndex);

                        AdvanceToBar(_currentBarIndex);
                    }
                }
            }
        }

        private void OpenHtmlChartsButton_Click(object sender, RoutedEventArgs e)
        {
            // TODO: Implement HTML charts opening
            MessageBox.Show("HTML charts feature not yet implemented", "Info", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            Close();
        }

        private void EmaVisibility_Changed(object sender, RoutedEventArgs e)
        {
            // Null check: checkboxes may not be initialized yet during component loading
            if (M15EmaCheckbox == null || H1EmaCheckbox == null)
                return;

            // Update visibility flags
            _showM15Emas = M15EmaCheckbox.IsChecked ?? false;
            _showH1Emas = H1EmaCheckbox.IsChecked ?? false;

            // Re-render chart with updated EMA visibility
            if (_playbackMode == PlaybackMode.RealM1 && _m1DataLoaded)
                RenderM1ChartUpToBar(_m1BarIndex);
            else
                RenderChartUpToBar(_currentBarIndex);
        }

        private void DiagnoseEmaIssues()
        {
            int totalM15 = _ohlcData.Candles.Count;
            var lastM15 = _ohlcData.Candles[totalM15 - 1];

            // Count how many M15 bars have EMA values
            int m15Ema20Count = _ohlcData.Candles.Count(c => c.Ema20_M15.HasValue && !double.IsNaN(c.Ema20_M15.Value));
            int m15Ema100Count = _ohlcData.Candles.Count(c => c.Ema100_M15.HasValue && !double.IsNaN(c.Ema100_M15.Value));
            int h1Ema20Count = _ohlcData.Candles.Count(c => c.Ema20_H1.HasValue && !double.IsNaN(c.Ema20_H1.Value));
            int h1Ema100Count = _ohlcData.Candles.Count(c => c.Ema100_H1.HasValue && !double.IsNaN(c.Ema100_H1.Value));

            // Find last bar with EMA values
            var lastM15WithEma20 = _ohlcData.Candles.LastOrDefault(c => c.Ema20_M15.HasValue && !double.IsNaN(c.Ema20_M15.Value));
            var lastM15WithEma100 = _ohlcData.Candles.LastOrDefault(c => c.Ema100_M15.HasValue && !double.IsNaN(c.Ema100_M15.Value));
            var lastM15WithH1Ema = _ohlcData.Candles.LastOrDefault(c => c.Ema20_H1.HasValue && !double.IsNaN(c.Ema20_H1.Value));

            // Check for NaN values in last 20 bars
            var last20 = _ohlcData.Candles.Skip(Math.Max(0, totalM15 - 20)).ToList();
            int nanCount = last20.Count(c => double.IsNaN(c.Close) || c.Close == 0);

            // Build diagnostic message
            var msg = $"=== EMA DIAGNOSTIC REPORT ===\n\n" +
                      $"Total M15 Bars: {totalM15}\n" +
                      $"Last M15 Timestamp: {lastM15.GetDateTime()}\n\n" +
                      $"M15 EMA20 Coverage: {m15Ema20Count} / {totalM15} bars ({100.0 * m15Ema20Count / totalM15:F1}%)\n" +
                      $"M15 EMA100 Coverage: {m15Ema100Count} / {totalM15} bars ({100.0 * m15Ema100Count / totalM15:F1}%)\n" +
                      $"H1 EMA20 Coverage: {h1Ema20Count} / {totalM15} bars ({100.0 * h1Ema20Count / totalM15:F1}%)\n" +
                      $"H1 EMA100 Coverage: {h1Ema100Count} / {totalM15} bars ({100.0 * h1Ema100Count / totalM15:F1}%)\n\n" +
                      $"Last M15 EMA20 at: {lastM15WithEma20?.GetDateTime()}\n" +
                      $"Last M15 EMA100 at: {lastM15WithEma100?.GetDateTime()}\n" +
                      $"Last H1 EMA at: {lastM15WithH1Ema?.GetDateTime()}\n\n" +
                      $"NaN/Zero Close prices in last 20 bars: {nanCount}\n\n" +
                      $"Time gap from last EMA to last candle:\n" +
                      $"  M15 EMA20: {(lastM15.GetDateTime() - lastM15WithEma20?.GetDateTime())?.TotalHours:F2} hours\n" +
                      $"  M15 EMA100: {(lastM15.GetDateTime() - lastM15WithEma100?.GetDateTime())?.TotalHours:F2} hours\n" +
                      $"  H1 EMA: {(lastM15.GetDateTime() - lastM15WithH1Ema?.GetDateTime())?.TotalHours:F2} hours";

            System.Diagnostics.Debug.WriteLine(msg);
            MessageBox.Show(msg, "EMA Diagnostic Report", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void PreCalculateMultiTimeframeEMAs()
        {
            if (_ohlcData == null || _ohlcData.Candles == null || _ohlcData.Candles.Count == 0)
                return;

            // DEBUG: Check if Python EMAs are being received from API
            int pythonEmaFastCount = _ohlcData.Candles.Count(c => c.EmaFast.HasValue);
            int pythonEmaMidCount = _ohlcData.Candles.Count(c => c.EmaMid.HasValue);
            int pythonEmaSlowCount = _ohlcData.Candles.Count(c => c.EmaSlow.HasValue);
            System.Diagnostics.Debug.WriteLine($"[PYTHON EMAs RECEIVED] EmaFast={pythonEmaFastCount}, EmaMid={pythonEmaMidCount}, EmaSlow={pythonEmaSlowCount} out of {_ohlcData.Candles.Count}");

            if (pythonEmaFastCount > 0)
            {
                System.Diagnostics.Debug.WriteLine($"[PYTHON EMAs] First 5 candles:");
                for (int i = 0; i < Math.Min(5, _ohlcData.Candles.Count); i++)
                {
                    var c = _ohlcData.Candles[i];
                    System.Diagnostics.Debug.WriteLine($"  {i}: {c.Timestamp} | EmaFast={c.EmaFast} | EmaMid={c.EmaMid} | EmaSlow={c.EmaSlow}");
                }
            }

            // Step 1: Use Python-calculated M15 EMAs
            // Python calculates EMAs on the FULL dataset (including warmup)
            foreach (var candle in _ohlcData.Candles)
            {
                candle.Ema20_M15 = candle.EmaFast;   // Python M15 EMA 20
                candle.Ema50_M15 = candle.EmaMid;    // Python M15 EMA 50
                candle.Ema100_M15 = candle.EmaSlow;  // Python M15 EMA 100
            }

            // DEBUG: Check if M15 EMAs were received
            int m15Ema20Count = _ohlcData.Candles.Count(c => c.Ema20_M15.HasValue);
            int m15Ema100Count = _ohlcData.Candles.Count(c => c.Ema100_M15.HasValue);
            if (ENABLE_VERBOSE_DEBUG)
                System.Diagnostics.Debug.WriteLine($"[PreCalc] M15 EMAs: EMA20={m15Ema20Count}, EMA100={m15Ema100Count} out of {_ohlcData.Candles.Count} candles");
            if (m15Ema20Count == 0)
            {
                MessageBox.Show($"WARNING: M15 EMAs were NOT received from Python! Total candles: {_ohlcData.Candles.Count}",
                    "EMA Data Missing", MessageBoxButton.OK, MessageBoxImage.Warning);
            }

            // Step 2: Use Python-calculated H1 EMAs (pre-calculated with full warmup)
            // This ensures H1 EMAs are accurate from the first bar
            foreach (var candle in _ohlcData.Candles)
            {
                candle.Ema20_H1 = candle.Ema20H1Python;   // Python H1 EMA 20
                candle.Ema50_H1 = candle.Ema50H1Python;   // Python H1 EMA 50
                candle.Ema100_H1 = candle.Ema100H1Python; // Python H1 EMA 100
            }

            // DEBUG: Check if H1 EMAs were received
            int h1Ema20Count = _ohlcData.Candles.Count(c => c.Ema20_H1.HasValue);
            int h1Ema100Count = _ohlcData.Candles.Count(c => c.Ema100_H1.HasValue);
            if (ENABLE_VERBOSE_DEBUG)
                System.Diagnostics.Debug.WriteLine($"[PreCalc] H1 EMAs: EMA20={h1Ema20Count}, EMA100={h1Ema100Count} out of {_ohlcData.Candles.Count} candles");
            if (h1Ema20Count == 0)
            {
                System.Diagnostics.Debug.WriteLine($"[WARN] H1 EMAs were NOT received from Python - will be null during playback");
            }
        }

        private List<CandleData> AggregateToH1(List<CandleData> m15Candles)
        {
            var h1Bars = new List<CandleData>();

            // Group by hour timestamp (align to proper H1 boundaries: 00:00, 01:00, 02:00, etc.)
            var groupedByHour = m15Candles
                .GroupBy(c => {
                    var dt = c.GetDateTime();
                    return new DateTime(dt.Year, dt.Month, dt.Day, dt.Hour, 0, 0);  // Round down to hour
                })
                .OrderBy(g => g.Key);

            foreach (var group in groupedByHour)
            {
                var groupBars = group.ToList();

                var h1Bar = new CandleData
                {
                    Timestamp = group.Key.ToString("yyyy-MM-dd HH:mm:ss"),  // Aligned to hour boundary
                    Open = groupBars[0].Open,
                    High = groupBars.Max(c => c.High),
                    Low = groupBars.Min(c => c.Low),
                    Close = groupBars[groupBars.Count - 1].Close  // Last bar's close
                };

                h1Bars.Add(h1Bar);
            }

            return h1Bars;
        }


        private void CalculateEMA(List<CandleData> candles, int period, Action<CandleData, double?> setter)
        {
            if (candles.Count < period)
                return;

            double multiplier = 2.0 / (period + 1);

            // Calculate initial SMA for first EMA value
            double sum = 0;
            for (int i = 0; i < period; i++)
            {
                // Validate Close price before using it
                if (double.IsNaN(candles[i].Close) || double.IsInfinity(candles[i].Close))
                {
                    if (ENABLE_VERBOSE_DEBUG)
                        System.Diagnostics.Debug.WriteLine($"WARNING: Invalid Close price at bar {i}: {candles[i].Close}. EMA calculation aborted.");
                    return;  // Abort EMA calculation if data is invalid
                }
                sum += candles[i].Close;
            }
            double ema = sum / period;
            setter(candles[period - 1], ema);

            // Calculate EMA for remaining candles
            for (int i = period; i < candles.Count; i++)
            {
                // Validate Close price before using it
                if (double.IsNaN(candles[i].Close) || double.IsInfinity(candles[i].Close))
                {
                    if (ENABLE_VERBOSE_DEBUG)
                        System.Diagnostics.Debug.WriteLine($"WARNING: Invalid Close price at bar {i}: {candles[i].Close}. EMA calculation stopped at bar {i - 1}.");
                    return;  // Stop EMA calculation if we hit invalid data
                }

                ema = (candles[i].Close - ema) * multiplier + ema;

                // Validate calculated EMA value
                if (double.IsNaN(ema) || double.IsInfinity(ema))
                {
                    System.Diagnostics.Debug.WriteLine($"WARNING: EMA calculation produced invalid value at bar {i}. EMA calculation stopped at bar {i - 1}.");
                    return;  // Stop if EMA becomes invalid
                }

                setter(candles[i], ema);
            }
        }

        protected override void OnClosed(EventArgs e)
        {
            base.OnClosed(e);
            if (_playbackTimer != null)
            {
                _playbackTimer.Stop();
            }
        }

        // ===== ENHANCEMENT #1: Recent Trades Tab Support =====

        private DateTime GetCurrentPlaybackTime()
        {
            // Return current playback time based on playback mode
            if (_playbackMode == PlaybackMode.RealM1 && _m1DataLoaded && _ohlcData.M1Candles != null && _m1BarIndex < _ohlcData.M1Candles.Count)
            {
                return _ohlcData.M1Candles[_m1BarIndex].GetDateTime();
            }
            else if (_currentBarIndex < _ohlcData.Candles.Count)
            {
                return _ohlcData.Candles[_currentBarIndex].GetDateTime();
            }
            // Fallback: return end date if indices are out of range
            return DateTime.Parse(_ohlcData.EndDate);
        }

        private void PopulateRecentTradesList()
        {
            // Phase 8.2.3: Handle both single-pair and multi-pair modes
            if (_isMultiPair)
            {
                // Multi-pair: Use all trades across all pairs
                if (_allTradesChronological == null || _allTradesChronological.Count == 0)
                    return;

                // Get current playback time for filtering
                DateTime currentTime = GetCurrentPlaybackTime();

                // Convert TradeRecord to TradeListItem with chronological order
                var recentTrades = _allTradesChronological
                    .Where(t => t.ExitTime != null) // Only closed trades
                    .Where(t => DateTime.Parse(t.ExitTime) <= currentTime) // Filter by playback time
                    .OrderByDescending(t => DateTime.Parse(t.ExitTime))
                    .Select(t => new TradeListItem
                    {
                        Symbol = t.Symbol,
                        TicketNumber = t.PositionId,
                        Side = t.Side,
                        RMultiple = t.RMultiple ?? 0.0,
                        IsWin = (t.RMultiple ?? 0) > 0,
                        Strategy = t.Strategy,
                        EntryTime = DateTime.Parse(t.EntryTime),
                        ExitTime = string.IsNullOrEmpty(t.ExitTime) ? (DateTime?)null : DateTime.Parse(t.ExitTime),
                        OriginalTrade = null // No TradeWithLevels for multi-pair yet
                    })
                    .ToList();

                RecentTradesListView.ItemsSource = recentTrades;
            }
            else
            {
                // Single-pair: Use existing logic
                if (_ohlcData == null || _ohlcData.Trades == null)
                    return;

                // Get current playback time for filtering
                DateTime currentTime = GetCurrentPlaybackTime();

                // Get ALL closed trades that have exited at or before current playback time
                // Sorted by exit time (most recent first)
                var recentTrades = _ohlcData.Trades
                    .Where(t => t.ExitPrice.HasValue) // Only closed trades
                    .Where(t => t.GetExitTime().Value <= currentTime) // Filter by playback time
                    .OrderByDescending(t => t.GetExitTime())
                    .Select(t => new TradeListItem
                    {
                        Symbol = _ohlcData.Symbol,
                        TicketNumber = t.TicketNumber,
                        Side = t.Side,
                        RMultiple = t.RMultiple ?? 0.0,
                        IsWin = t.IsWin,
                        Strategy = t.Strategy,
                        EntryTime = t.GetEntryTime(),
                        ExitTime = t.GetExitTime(),
                        OriginalTrade = t
                    })
                    .ToList();

                RecentTradesListView.ItemsSource = recentTrades;
            }
        }

        private void RecentTradeSelected(object sender, System.Windows.Controls.SelectionChangedEventArgs e)
        {
            var selected = RecentTradesListView.SelectedItem as TradeListItem;
            if (selected != null)
            {
                // Phase 8.2.3: Auto-switch pair tab if multi-pair mode
                if (_isMultiPair && selected.Symbol != _currentPair)
                {
                    SwitchToPairTab(selected.Symbol);
                }

                // Show trade details (handle both single and multi-pair)
                if (selected.OriginalTrade != null)
                {
                    TradeDetailsPanel.Visibility = Visibility.Visible;
                    TradeDetailsText.Text = FormatTradeDetails(selected.OriginalTrade);

                    // Jump to trade on timeline if checkbox is checked
                    if (JumpToTradeCheckbox.IsChecked == true)
                    {
                        JumpToTradeOnTimeline(selected.OriginalTrade);
                    }
                }
                else
                {
                    // Multi-pair mode: Show basic trade details
                    TradeDetailsPanel.Visibility = Visibility.Visible;
                    TradeDetailsText.Text = FormatTradeDetailsFromListItem(selected);

                    // Jump to trade time
                    if (JumpToTradeCheckbox.IsChecked == true && selected.ExitTime.HasValue)
                    {
                        JumpToTradeTime(selected.ExitTime.Value);
                    }
                }
            }
            else
            {
                TradeDetailsPanel.Visibility = Visibility.Collapsed;
            }
        }

        // Phase 8.2.3: Format trade details from TradeListItem (multi-pair mode)
        private string FormatTradeDetailsFromListItem(TradeListItem trade)
        {
            var details = $"Ticket: #{trade.TicketNumber}\n" +
                         $"Symbol: {trade.Symbol}\n" +
                         $"Strategy: {trade.Strategy}\n" +
                         $"Side: {trade.Side}\n" +
                         $"Entry: {trade.EntryTime:yyyy-MM-dd HH:mm}\n" +
                         $"Exit: {trade.ExitTime:yyyy-MM-dd HH:mm}\n" +
                         $"R-Multiple: {trade.RMultiple:+0.00}R\n" +
                         $"Result: {(trade.IsWin ? "WIN" : "LOSS")}";

            return details;
        }

        // Phase 8.2.3: Jump to specific trade time (multi-pair mode)
        private void JumpToTradeTime(DateTime tradeTime)
        {
            // Stop playback
            StopPlayback();

            // Find bar index for trade time
            int barIndex = FindBarIndex(tradeTime);
            if (barIndex < 0 || barIndex >= _ohlcData.Candles.Count)
                return;

            // Advance to that bar
            AdvanceToBar(barIndex);
        }

        // Phase 8.2.4: Position slot click handler (auto-switch for multi-pair)
        private void PositionSlot_Click(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            if (sender is System.Windows.Controls.Border border && border.Tag is TradeWithLevels trade)
            {
                // Auto-switch pair tab if multi-pair mode and different pair
                if (_isMultiPair && trade.Symbol != _currentPair)
                {
                    SwitchToPairTab(trade.Symbol);
                }

                // Show trade details
                TradeDetailsPanel.Visibility = Visibility.Visible;
                TradeDetailsText.Text = FormatTradeDetails(trade);

                // Jump to trade entry time if checkbox is checked
                if (JumpToTradeCheckbox.IsChecked == true)
                {
                    JumpToTradeOnTimeline(trade);
                }
            }
        }

        private string FormatTradeDetails(TradeWithLevels trade)
        {
            var details = $"Ticket: #{trade.TicketNumber}\n" +
                         $"Symbol: {_ohlcData.Symbol}\n" +
                         $"Strategy: {trade.Strategy}\n" +
                         $"Side: {trade.Side}\n" +
                         $"Entry: {trade.EntryPrice:F5} @ {trade.GetEntryTime():yyyy-MM-dd HH:mm}\n" +
                         $"Exit: {trade.ExitPrice:F5} @ {trade.GetExitTime():yyyy-MM-dd HH:mm}\n" +
                         $"TP: {trade.TakeProfit:F5} | SL: {trade.StopLoss:F5}\n" +
                         $"R-Multiple: {trade.RMultiple:+0.00}R\n" +
                         $"Result: {(trade.IsWin ? "WIN" : "LOSS")}\n" +
                         $"Exit Reason: {trade.ExitReason}";

            return details;
        }

        private void JumpToTradeOnTimeline(TradeWithLevels trade)
        {
            var exitTime = trade.GetExitTime();
            if (!exitTime.HasValue)
                return;

            // Stop playback
            StopPlayback();

            // Find bar index for exit time
            int barIndex = FindBarIndex(exitTime.Value);
            if (barIndex < 0 || barIndex >= _ohlcData.Candles.Count)
                return;

            // Reset and replay trades up to this point
            _currentBarIndex = barIndex;
            _m1BarIndex = barIndex * 15; // Approximate M1 index
            _cumulativeR = 0.0;
            _winsCount = 0;
            _lossesCount = 0;
            _activeTrades.Clear();
            _savedAxisLimits = null;

            // Replay trades up to selected trade
            ReplayTradesUpToBar(barIndex);

            // Advance to the bar
            if (_playbackMode == PlaybackMode.RealM1 && _m1DataLoaded && _ohlcData.M1Candles != null)
                AdvanceToM1Bar(_m1BarIndex);
            else
                AdvanceToBar(barIndex);
        }
    }

    // ===== TradeListItem Model for ListView =====
    public class TradeListItem
    {
        public string Symbol { get; set; }
        public long TicketNumber { get; set; }
        public string Side { get; set; }
        public double RMultiple { get; set; }
        public bool IsWin { get; set; }
        public string Strategy { get; set; }
        public DateTime EntryTime { get; set; }
        public DateTime? ExitTime { get; set; }
        public TradeWithLevels OriginalTrade { get; set; }

        // Phase 8.2.3: Updated format with pair and duration - "âœ“ [EURUSD] 14:30 BUY +2.0R (2h15m) #45"
        public string CompactDisplay
        {
            get
            {
                string icon = IsWin ? "âœ“" : "âœ—";
                string entryTime = EntryTime.ToString("HH:mm");

                // Calculate duration
                string duration = "";
                if (ExitTime.HasValue)
                {
                    TimeSpan diff = ExitTime.Value - EntryTime;
                    if (diff.TotalHours >= 1)
                    {
                        int hours = (int)diff.TotalHours;
                        int minutes = diff.Minutes;
                        duration = $" ({hours}h{minutes:00}m)";
                    }
                    else if (diff.TotalMinutes >= 1)
                    {
                        int minutes = (int)diff.TotalMinutes;
                        duration = $" ({minutes}m)";
                    }
                    else
                    {
                        duration = " (<1m)";
                    }
                }

                return $"{icon} [{Symbol}] {entryTime} {Side} {RMultiple:+0.0;-0.0}R{duration} #{TicketNumber}";
            }
        }

        // Computed property for text color
        public System.Windows.Media.Brush TextColor
        {
            get
            {
                return IsWin
                    ? new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(0, 170, 0)) // Green
                    : new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 68, 68)); // Red
            }
        }
    }

    // Phase 8.3: Trade timeline event for visual timeline
    public class TradeTimelineEvent
    {
        public DateTime Timestamp { get; set; }
        public string Pair { get; set; }
        public string EventType { get; set; } // "ENTRY" or "EXIT"
        public int TradeId { get; set; }
        public string Side { get; set; } // "LONG" or "SHORT"
        public double? RMultiple { get; set; }
        public string Strategy { get; set; }
        public int GlobalTimelineIndex { get; set; } // Index in global timeline for jump navigation
    }
}
